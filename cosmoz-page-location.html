<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-location/iron-location.html">
<link rel="import" href="../iron-location/iron-query-params.html">
<!--
The `cosmoz-page-location` element manages binding to and from the current URL.

@demo demo/location.html
-->
<dom-module id="cosmoz-page-location">
	<template>
		<iron-location url-space-regex="^$" id="location"
			path="{{ appPath }}"
			query="{{ _appQueryString }}"
			hash="{{ _appHashString }}">
		</iron-location>

		<iron-query-params id="params"
		></iron-query-params>

	</template>
	<script>
		(function () {
			'use strict';

			const defaultObject = function () {
					return {};
				},
				assign = Object.assign;

			Polymer({
				is: 'cosmoz-page-location',
				properties: {
					appPath: {
						type: String,
						notify: true
					},

					_appQueryString: {
						type: String
					},

					_appHashString: {
						type: String
					},

					routePath: {
						type: String,
						notify: true,
						observer: '_routeChanged'
					},

					routeQuery: {
						type: Object,
						value: defaultObject,
						notify: true
					},

					routeHash: {
						type: Object,
						value: defaultObject,
						notify: true
					},

					hashBang: {
						type: Boolean,
						readOnly: true
					}
				},

				observers: [
					'_routeChanged(routeQuery.*)',
					'_routeChanged(routeHash.*)',
					'_appHashChanged(_appHashString)',
				],

				_paramsToString(value) {
					if (typeof value === 'string') {
						return value;
					}
					return this.$.params._encodeParams(value)
						.replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');
				},

				_paramsFromString(value) {
					return this.$.params._decodeParams(value);
				},

				_microUpdate(path, value = {}) {
					const keys = Object.keys,
						current = this.get(path),
						currentKeys = keys(current);
					let valueKeys = keys(value);

					currentKeys
						.filter(key => valueKeys.indexOf(key) < 0)
						.forEach(key => value[key] = null);

					keys(value)
						.filter(key => current[key] !== value[key])
						.forEach(key => this.set([path, key], value[key]));
				},

				_parse(appHashString) {
					let regexp = /(!(?=\/))?([^#?]+)?#?([^?]+)?\??(.+)?$/gi,
						matches = regexp.exec(appHashString);
					matches = matches && matches.slice(1);
					return {
						hashBang: !!matches[0],
						path: matches[1] || '',
						hash: this._paramsFromString(matches[2]),
						query: this._paramsFromString(matches[3]),
					};
				},

				_encode(route = {}, queryFirst) {
					let string = (route.hashBang ? '!' : '') + (route.path || ''),
						query = this._paramsToString(route.query),
						hash = this._paramsToString(route.hash),
						hashAndQuery = [
							hash ? '#' + hash.replace(/\?/g, '%3F') : '',
							query ? '?' + query.replace(/#/g, '%23') : ''
						];

					if (queryFirst) {
						hashAndQuery.reverse();
					}

					return string + hashAndQuery.join('');
				},

				get route() {
					return {
						hashBang: this.hashBang,
						path: this.routePath,
						hash: assign({}, this.routeHash),
						query: assign({}, this.routeQuery)
					};
				},

				getRouteUrl(route = this.route) {
					return '#' + this._encode(route);
				},

				getAppUrl(query, route = this.route) {
					let appQuery = this._appQueryString;

					if (query && typeof query === 'object') {
						appQuery = assign({}, this._paramsFromString(appQuery), query);
					}

					return this._encode({
						path: this.appPath,
						query: appQuery,
						hash: this._encode(route)
					}, true);
				},

				_appHashChanged(_appHashString) {
					const route = this._parse(_appHashString);
					this._setHashBang(route.hashBang);
					this.routePath = route.path;
					this._microUpdate('routeHash', route.hash);
					this._microUpdate('routeQuery', route.query);
				},

				_routeChanged() {
					if (!this.isAttached) {
						return;
					}
					this._appHashString = this._encode(this.route);
				}
			});
		})();
	</script>
</dom-module>
