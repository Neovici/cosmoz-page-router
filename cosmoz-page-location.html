<link rel="import" href="../shadycss/apply-shim.html">
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../iron-location/iron-location.html">
<link rel="import" href="../iron-location/iron-query-params.html">
<!--
The `cosmoz-page-location` element manages binding to and from the current URL.

@demo demo/location.html
-->
<dom-module id="cosmoz-page-location">
	<template>
		<iron-location url-space-regex="^$" id="location"
			path="{{ appPath }}"
			query="{{ _appQueryString }}"
			hash="{{ _appHashString }}">
		</iron-location>
		<iron-query-params id="params"></iron-query-params>
	</template>
	<script>
		(function () {
			'use strict';

			class CosmozPageLocation extends Polymer.Element {
				constructor() {
					super();
					this._parseRegexp = /(!(?=\/))?([^#?]+)?\??([^#]+)?#?(.+)?$/i;
				}

				static get is() {
					return 'cosmoz-page-location';
				}

				static get properties() {
					return {
						appPath: {
							type: String,
							notify: true
						},

						_appQueryString: {
							type: String
						},

						_appHashString: {
							type: String
						},

						routePath: {
							type: String,
							notify: true,
						},

						routeQuery: {
							type: Object,
							value() {
								return {};
							},
							notify: true
						},

						routeHash: {
							type: Object,
							value() {
								return {};
							},
							notify: true
						},

						dwellTime: {
							type: Number,
							value: 2000
						},

						microDwellTime: {
							type: Number,
							value: Infinity
						},

						hashBang: {
							type: Boolean,
							readOnly: true
						}
					};
				}

				static get observers() {
					return [
						'_appHashChanged(_appHashString, setProperties)',
						'_routeChanged(routeQuery.*, isAttached, routeHash, _appHashString, microDwellTime, dwellTime)',
						'_routeChanged(routeHash.*, isAttached, routeHash, _appHashString, microDwellTime, dwellTime)'
					];
				}

				_paramsToString(value) {
					if (typeof value === 'string') {
						return value;
					}
					return this.$.params._encodeParams(value)
						.replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');
				}

				_paramsFromString(value) {
					return this.$.params._decodeParams(value);
				}

				_microUpdate(path, value = {}) {
					const current = this.get(path),
						valueKeys = Object.keys(value);

					// In the new object set deleted properties to null
					Object.keys(current).forEach(key =>  {
						if (valueKeys.indexOf(key) > -1) {
							return;
						}
						value[key] = null;
					});

					//Update changed keys
					Object.keys(value).forEach(key => {
						if (current[key] === value[key]) {
							return;
						}
						this.set([path, key], value[key]);
					});
				}

				_batchMicroUpdate(props) {
					const updatedPaths = {};

					Object.keys(props).forEach(path => {
						let currentPropValue = this.get(path),
							newPropValue = props[path],
							newPropValueKeys = Object.keys(newPropValue);

						if (typeof currentPropValue !== 'object') {
							if (currentPropValue !== newPropValue) {
								updatedPaths[path] = newPropValue;
							}
							return;
						}

						// Set deleted properties to null
						Object.keys(currentPropValue).forEach(subPath => {
							if (newPropValueKeys.indexOf(subPath) < 0) {
								updatedPaths[path + '.' + subPath] = null;
							}
						});
						// Update changed properties
						Object.keys(newPropValue).forEach(subPath => {
							if (currentPropValue[subPath] === newPropValue[subPath]) {
								return;
							}
							updatedPaths[path + '.' + subPath] = newPropValue[subPath];
						});
					});

					this.setProperties(updatedPaths);
				}

				_parse(appHashString) {
					const matches = this._parseRegexp.exec(appHashString) || [];
					return {
						hashBang: !!matches[1],
						path: matches[2] || '',
						query: this._paramsFromString(matches[3]),
						hash: this._paramsFromString(matches[4])
					};
				}

				_encode(route = {}) {
					const path = (route.hashBang ? '!' : '') + (route.path || ''),
						query = this._paramsToString(route.query),
						hash = this._paramsToString(route.hash),
						hashAndQuery = [
							query ? '?' + query.replace(/#/g, '%23') : '',
							hash ? '#' + hash.replace(/\?/g, '%3F') : ''
						];
					return path + hashAndQuery.join('');
				}

				getRoute() {
					return {
						hashBang: this.hashBang,
						path: this.routePath,
						query: Object.assign({}, this.routeQuery),
						hash: Object.assign({}, this.routeHash),
					};
				}

				getRouteUrl(route = this.getRoute()) {
					return '#' + this._encode(route);
				}

				getAppUrl(query, route = this.getRoute()) {
					let appQuery = this._appQueryString;

					if (query && typeof query === 'object') {
						appQuery = Object.assign({}, this._paramsFromString(appQuery), query);
					}

					return this._encode({
						path: this.appPath,
						query: appQuery,
						hash: this._encode(route)
					});
				}

				_appHashChanged(_appHashString, setProperties) {
					const route = this._parse(_appHashString);
					this._setHashBang(route.hashBang);

					if (setProperties) {
						// Batch update of properties if using Polymer 2.x
						this._batchMicroUpdate({
							routePath: route.path,
							routeHash: route.hash,
							routeQuery: route.query
						});
					} else {
						this.set('routePath', route.path);
						this._microUpdate('routeHash', route.hash);
						this._microUpdate('routeQuery', route.query);
					}
				}

				_routeChanged(change, isAttached, routeHash, _appHashString, microDwellTime, dwellTime) {
					if (!isAttached) {
						return;
					}

					const path = change && change.path;

					let route,
						routeHashUri;

					if (path && path.startsWith('routeHash')) {
						// See issue #36
						// If this cosmoz-page-location query parameters are not in sync with the URL, and we are trying to update
						// some hash params, then we will update the URL with incorrect route hash string
						// To avoid that, use the actual location
						route = this._parse(window.decodeURIComponent(window.location.hash.slice(1)));
						routeHashUri = this._encode({ hashBang: route.hashBang, path: route.path, query: route.query, hash: routeHash });
					} else {
						route = this.getRoute();
						routeHashUri = this._encode(route);
					}

					if (_appHashString === routeHashUri) {
						return;
					}

					this.$.location.dwellTime = path && path.length ? microDwellTime : dwellTime;
					this.set('_appHashString', routeHashUri);
				}
			}

			customElements.define(CosmozPageLocation.is, CosmozPageLocation);
		})();
	</script>
</dom-module>
