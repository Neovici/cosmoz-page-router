<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-location/iron-location.html">
<link rel="import" href="../iron-location/iron-query-params.html">
<!--
The `cosmoz-page-location` element manages binding to and from the current URL.

@demo demo/location.html
-->
<dom-module id="cosmoz-page-location">
	<template>
		<iron-location url-space-regex="^$" id="location"
			path="{{ appPath }}"
			query="{{ _appQueryString }}"
			hash="{{ _appHashString }}">
		</iron-location>
		<iron-query-params id="params"></iron-query-params>
	</template>
	<script>
		(function () {
			'use strict';

			Polymer({
				is: 'cosmoz-page-location',
				properties: {
					appPath: {
						type: String,
						notify: true
					},

					_appQueryString: {
						type: String
					},

					_appHashString: {
						type: String,
						observer: '_appHashChanged'
					},

					routePath: {
						type: String,
						notify: true,
						observer: '_routeChanged'
					},

					routeQuery: {
						type: Object,
						value: function () {
							return {};
						},
						notify: true
					},

					routeHash: {
						type: Object,
						value: function () {
							return {};
						},
						notify: true
					},

					hashBang: {
						type: Boolean,
						readOnly: true
					}
				},
				_parseRegexp: /(!(?=\/))?([^#?]+)?#?([^?]+)?\??(.+)?$/i,

				observers: [
					'_routeChanged(routeQuery.*)',
					'_routeChanged(routeHash.*)'
				],

				_paramsToString(value) {
					if (typeof value === 'string') {
						return value;
					}
					return this.$.params._encodeParams(value)
						.replace(/%3F/g, '?').replace(/%2F/g, '/').replace(/'/g, '%27');
				},

				_paramsFromString(value) {
					return this.$.params._decodeParams(value);
				},

				_microUpdate(path, value = {}) {
					const current = this.get(path),
						valueKeys = Object.keys(value);

					// In the new object set deleted properties to null
					Object.keys(current).forEach(key =>  {
						if (valueKeys.indexOf(key) > -1) {
							return;
						}
						value[key] = null;
					});

					//Update changed keys
					Object.keys(value).forEach(key => {
						if (current[key] === value[key]) {
							return;
						}
						this.set([path, key], value[key]);
					});
				},

				_parse(appHashString) {
					const matches = this._parseRegexp.exec(appHashString) || [];
					return {
						hashBang: !!matches[1],
						path: matches[2] || '',
						hash: this._paramsFromString(matches[3]),
						query: this._paramsFromString(matches[4]),
					};
				},

				_encode(route = {}, queryFirst) {
					const path = (route.hashBang ? '!' : '') + (route.path || ''),
						query = this._paramsToString(route.query),
						hash = this._paramsToString(route.hash),
						hashAndQuery = [
							hash ? '#' + hash.replace(/\?/g, '%3F') : '',
							query ? '?' + query.replace(/#/g, '%23') : ''
						];

					if (queryFirst) {
						hashAndQuery.reverse();
					}

					return path + hashAndQuery.join('');
				},

				get route() {
					return {
						hashBang: this.hashBang,
						path: this.routePath,
						hash: Object.assign({}, this.routeHash),
						query: Object.assign({}, this.routeQuery)
					};
				},

				getRouteUrl(route = this.route) {
					return '#' + this._encode(route);
				},

				getAppUrl(query, route = this.route) {
					let appQuery = this._appQueryString;

					if (query && typeof query === 'object') {
						appQuery = Object.assign({}, this._paramsFromString(appQuery), query);
					}

					return this._encode({
						path: this.appPath,
						query: appQuery,
						hash: this._encode(route)
					}, true);
				},

				_appHashChanged(_appHashString) {
					const route = this._parse(_appHashString);
					this._setHashBang(route.hashBang);
					this.routePath = route.path;
					this._microUpdate('routeHash', route.hash);
					this._microUpdate('routeQuery', route.query);
				},

				_routeChanged() {
					if (!this.isAttached) {
						return;
					}
					this._appHashString = this._encode(this.route);
				}
			});
		})();
	</script>
</dom-module>
